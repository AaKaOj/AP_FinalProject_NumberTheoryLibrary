#include<stdbool.h>
#include<stdio.h>
#include<stdlib.h> 

bool isPrime(int n)
{
    bool flag=true;
    for (int i=2; i<=sqrt((double)n) && flag; i++)
    {
        if (n%i==0) 
        {
            flag=false;
        }
    }
    if (n==1)
        flag = false;
    return flag;
}

int nextPrime(int n)
{
    for (int i=n+1; ; i++)
    {
        if (isPrime(i))
            return i;
    }
}

int prevPrime(int n)
{
    if(n<=2)
    	return 2;
    else
    {
        for (int i=n-1; i>1 ; i--)
        {
            if (isPrime(i))
            return i;
        }
    }
}

int nearestPrime(int n)
{
    if (n<=1)
        return 2;
    else
    {
        int prev=prevPrime(n);
        int next=nextPrime(n);
        int prevdiff=n-prev;
        int nextdiff=next-n;
        if(prevdiff<=nextdiff)
            return prev;
        else
            return next;
    }
}

long factorial (int n)
{
    int fact=1;
    for (int i=n; i>0; i--)
    {
        fact*=i;
    }
    return fact;
}

int sumUpto(int n)
{
    int sum= (n*(n+1))/2;
    return sum;
}

int inverseMod(int a, int m) 
{ 
    a = modulo(a,m); 
    for (int x=1; x<m; x++) 
       if ((a*x) % m == 1) 
          return x; 
} 

bool areCoPrime(int a, int b)
{
    int gcd=GCD(a,b);
    if (gcd==1)
        return true;
    else
        return false;
}

int exponent(int a, int b)
{
    int e=1;
    for(int i=0; i<b; i++)
    {
        e*=a;
    }
    return e;
}

int modExp(int a, int b, int mod)
{
   int num=exponent(a,b);
   return modula(num, mod);
}

int countFactors (int n)
{
    int count=0;
    for(int i=1; i<=n; i++)
    {
        if (n%i==0)
            count++;
    }
    return count;
}

int countPrimeFactors (int n)
{
    int count=0;
    for(int i=1; i<=n; i++)
    {
        if (n%i==0 && isPrime(i))
            count++;
    }
    return count;
}

int modAdd (int a, int b, int mod)
{
    int sum=a+b;
    return (sum%mod);
}

int subMod (int a, int b, int mod)
{
    int diff=a-b;
    return(diff%mod);
}

int multiplyMod (int a, int b, int mod)
{
    int prod=a*b;
    return (prod%mod);
}

//Functions in MODULAR ARITHMETIC

//function to calculate 'a modulo b' or 'a mod b', b > 0.
//this function essentially does the job of the modulo operator i.e. '%'.
//it calculates the remainder when a is divided by b. That is, it gives us the 'r' in: 'a = bq + r'.
int calculatemod(int a, int b)
{
	//Note: I am assuming that modulus operations can't take place for negative divisors i.e. b must be positive.
	if(b <= 0)
	{
		printf("");
		printf("Operation not possible since in 'a (mod b)', b must be postive.\n"); 
		return -1;
	}
	//'a mod b = 0' for all values of a if b = 1.
	else if(b == 1)
	{
		return 0;
	}
	//if b is positive and not equal to a.
	else
	{
		//if a is positive but less than b then 'a mod b' is equal to a.
		if(a > 0 && a < b)
		{
			return a;
		}
		//NOTE: Some computer programs/languages such as C, R, etc, sometimes give a negative modulus.
		//However, we are going by the assumption that modulus only takes non-negative values.
		//if a is negative.
		else if(a < 0)
		{
			//as long as a is negative, keep adding b to it. After that, a mod b = a.
			while(a < 0)
			{
				a += b;
			}
			return a;
		}
		//if a is greater than equal to b.
		else
		{
			//keep subtracting b from a until a < b. After that, a mod b = a.
			while(a >= b)
			{
				a -= b;
			}
			return a;
		}
	}
}

//function to check if 'a is congruent to b (modulo n)'.
void congruence(int a, int b, int n)
{
	if(calculatemod(a, n) == -1 || calculatemod(b, n) == -1)
	{
		printf("Operation not possible as the b in 'a (mod b)' must be positive.\n");
		return;
	}
	if(calculatemod(a, n) == calculatemod(b, n))
	{
			printf("%d is congruent to %d (modulo %d).\n", a, b, n);
	}
	else
	{
		printf("%d is not congruent to %d (modulo %d).\n", a, b, n);
	}
}

//Function for the Quotient Remainder Theorem.
//According to this theorem: 
//Given any integer a, and a positive integer b, there exist unique integers q and r such that
//a = b*q + r, where 0 <= r < b
void QRtheorem(int a, int b)
{
	if(b < 0)
	{
		printf("Invalid input, since 0 <= Integer 2\n");
	}
	else
	{
		int r = calculatemod(a, b);
		int q = (a - r)/b;
		printf("q = %d and r = %d\n", q, r);
	}	
}

//Functions in FACTORING ALGORITHMS

//function to calculate GCD of two integers
int gcd(int a, int b)
{
	a = abs(a);
	b = abs(b);
	int c, hcf;
	if(a > 0 && b > 0)
    {
    	if(a < b)
    	{
    		c = a;    
    	}
    	else
    	{
     		c = b;
    	}
    	for(int i = 1; i <= c; i++)
    	{
     		if(a % i == 0 && b % i == 0)
     		{
     			hcf = i;
     		}
    	}
    	return hcf;
    }
    else
    {
    	return a + b;
    }
}

//function to calculate the LCM of two integers
//Note: LCM(a, b) = a*b/GCD(a, b)
int lcm(int c, int d)
{
	return abs(c*d)/gcd(c, d);
}

int arrayGCD(int nums[], int n) 
{ 
    int g = nums[0]; 
    for (int i = 1; i < n; i++) 
        g = gcd(nums[i], g); 
    return g; 
} 

int arrayLCM(int nums[], int n)
{ 
    int l = nums[0]; 
    for (int i = 1; i < n; i++) 
        l = lcm(nums[i], l); 
    return l;
}

int* sortArray(int *arr, int n)
{
    int temp;
    for (int i=0; i<n ; i++)
    {
      for (int j = i + 1; j < n; j++)
      {
          if (arr[i] > arr[j])
          {
              temp=arr[i];
              arr[i] = arr[j];
              arr[j] = temp;
          }
      }
  }
  return arr;
}

int* listFactors (int n)
{
    int count=countFactors(n);
    int index=0;
    int *p;
    do
    {
        p=(int*)malloc(n*sizeof(int));
    }while(p==NULL);
    for(int i=1; i<sqrt(n); i++)
    {
        if(n%i==0)
        {
            p[index++]=i;
            p[index++]=(n/i);
        }
    }
    sortArray(p, count);
    return p;
}

int* listPrimeFactors (int n)
{
    int count=countPrimeFactors(n);
    int index=0;
    int *p;
    do
    {
        p=(int*)malloc(n*sizeof(int));
    }while(p==NULL);
    for(int i=1; i<sqrt(n); i++)
    {
        if(n%i==0 && isPrime(i))
        {
            p[index++]=i;
        }
    }
    sortArray(p, count);
    return p;
}

int countPrimesTill (int n)
{
    int count=0;
    for (int i=1; i<abs(n); i++)
    {
        if(isPrime(i))
            count++;
    }
    return count;
}

int* listPrimesTill (int n)
{
    int index=0;
    int c=countPrimesTill(n);
    int *p;
    do
    {
        p=(int*)malloc(c*sizeof(int));
    }while(p==NULL);
    for(int i=2; i<n; i++)
    {
        if(isPrime(i))
        {
            p[index++]=i;
        }
    }
    sortArray(p, c);
    return p;
}

int* listPrimes (int n)
{
    int index=0;
    int *p;
    do
    {
        p=(int*)malloc(n*sizeof(int));
    }while(p==NULL);
    for(int i=2; index<n; i++)
    {
        if(isPrime(i))
        {
            p[index++]=i;
        }
    }
    sortArray(p, n);
    return p;
}
