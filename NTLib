#include<stdbool.h>
#include<stdio.h>
#include<stdlib.h> 
#include<math.h>

typedef struct
{
   int quotient, remain; 
}QRT;

bool isPrime(int n)
{
    bool flag=true;
    for (int i=2; i<=sqrt((double)n) && flag; i++)
    {
        if (n%i==0) 
        {
            flag=false;
        }
    }
    if (n==1)
        flag = false;
    return flag;
}

int nextPrime(int n)
{
    for (int i=n+1; ; i++)
    {
        if (isPrime(i))
            return i;
    }
}

int prevPrime(int n)
{
    if(n<=2)
    	return 2;
    else
    {
        for (int i=n-1; i>1 ; i--)
        {
            if (isPrime(i))
            return i;
        }
    }
}

int nearestPrime(int n)
{
    if (n<=1)
        return 2;
    else
    {
        int prev=prevPrime(n);
        int next=nextPrime(n);
        int prevdiff=n-prev;
        int nextdiff=next-n;
        if(prevdiff<=nextdiff)
            return prev;
        else
            return next;
    }
}

long factorial (int n)
{
    int fact=1;
    for (int i=n; i>0; i--)
    {
        fact*=i;
    }
    return fact;
}

int sumUpto(int n)
{
    int sum= (n*(n+1))/2;
    return sum;
}

int inverseMod(int a, int m) 
{ 
    a = modulo(a,m); 
    for (int x=1; x<m; x++) 
       if ((a*x) % m == 1) 
          return x; 
} 

bool areCoPrime(int a, int b)
{
    int gcd=GCD(a,b);
    if (gcd==1)
        return true;
    else
        return false;
}

int exponent(int a, int b)
{
    int e=1;
    for(int i=0; i<b; i++)
    {
        e*=a;
    }
    return e;
}

int modExp(int a, int b, int mod)
{
   int num=exponent(a,b);
   return modula(num, mod);
}

int modSquare(int a, int mod)
{
   int num=a*a;
   return num%mod;
}


int countFactors (int n)
{
    int count=0;
    for(int i=1; i<=n; i++)
    {
        if (n%i==0)
            count++;
    }
    return count;
}

int countPrimeFactors (int n)
{
    int count=0;
    for(int i=1; i<=n; i++)
    {
        if (n%i==0 && isPrime(i))
            count++;
    }
    return count;
}

int modAdd (int a, int b, int mod)
{
    int sum=a+b;
    return (sum%mod);
}

int subMod (int a, int b, int mod)
{
    int diff=a-b;
    return(diff%mod);
}

int multiplyMod (int a, int b, int mod)
{
    int prod=a*b;
    return (prod%mod);
}

//Functions in MODULAR ARITHMETIC

//function to calculate 'a modulo b' or 'a mod b', b > 0.
//this function essentially does the job of the modulo operator i.e. '%'.
//it calculates the remainder when a is divided by b. That is, it gives us the 'r' in: 'a = bq + r'.
int getMod(int a, int b)
{
	bool neg=false;
	if(b==0)
	{
	    printf("ERROR: DIVISION BY ZERO\n");
	    return -1;
	}
	if(a<0 && b<0)
	{
		a=abs(a);
		b=abs(b);
		neg=true;
	}
	
	if((b == 1) || (a==b))
	{
		return 0;

	}
	else if (a>0 && b<0)
	{
	    while(a > 0)
			a += b;
		return a;
	}
	//if b is positive and not equal to a.
	else
	{ //if a is positive but less than b then 'a mod b' is equal to a.
		if(a > 0 && a < b)
		{
			if(neg)
			    a=0-a;
			return a;
		}
		else if(a < 0)
		{ //as long as a is negative, keep adding b to it. After that, a mod b = a.
			while(a < 0)
				a += b;
		}
		else 		//if a is greater than equal to b.
		{ //keep subtracting b from a until a < b. After that, a mod b = a. 
			while(a >= b)			
				a -= b;
		}
	}
	if(neg)
	    return (0-a);
	else
	    return a;
}

bool isCongruent(int a, int b, int n)
{
	if(getMod(a, n) == getMod(b, n))
	{
		return true;
	}
	else
	{
		return false;
	}
}

int discreteLogarithm(int a, int b, int mod)
{
    for (int i=0; i<mod; i++)
    {
        if(isCongruent(exponent(a,i), b, mod))
            return i;
    }
    return -1;
}

//Function for the Quotient Remainder Theorem.
//According to this theorem: 
//Given any integer a, and a positive integer b, there exist unique integers q and r such that
//a = b*q + r, where 0 <= r < b
QRT QRtheorem(int a, int b)
{
	QRT x;
	x.remain = calculatemod(a, b);
	x.quotient = (a - x.remain)/b;
	return x;
}

//Functions in FACTORING ALGORITHMS

//function to calculate GCD of two integers
int gcd(int a, int b)
{
	a = abs(a);
	b = abs(b);
	int c, hcf;
	if(a > 0 && b > 0)
    {
    	if(a < b)
    	{
    		c = a;    
    	}
    	else
    	{
     		c = b;
    	}
    	for(int i = 1; i <= c; i++)
    	{
     		if(a % i == 0 && b % i == 0)
     		{
     			hcf = i;
     		}
    	}
    	return hcf;
    }
    else
    {
    	return a + b;
    }
}

//function to calculate the LCM of two integers
//Note: LCM(a, b) = a*b/GCD(a, b)
int lcm(int c, int d)
{
	return abs(c*d)/gcd(c, d);
}

int arrayGCD(int nums[], int n) 
{ 
    int g = nums[0]; 
    for (int i = 1; i < n; i++) 
        g = gcd(nums[i], g); 
    return g; 
} 

int arrayLCM(int nums[], int n)
{ 
    int l = nums[0]; 
    for (int i = 1; i < n; i++) 
        l = lcm(nums[i], l); 
    return l;
}

int* sortArray(int *arr, int n)
{
    int temp;
    for (int i=0; i<n ; i++)
    {
      for (int j = i + 1; j < n; j++)
      {
          if (arr[i] > arr[j])
          {
              temp=arr[i];
              arr[i] = arr[j];
              arr[j] = temp;
          }
      }
  }
  return arr;
}

int* listFactors (int n)
{
    int count=countFactors(n);
    int index=0;
    int *p;
    do
    {
        p=(int*)malloc(n*sizeof(int));
    }while(p==NULL);
    for(int i=1; i<sqrt(n); i++)
    {
        if(n%i==0)
        {
            p[index++]=i;
            p[index++]=(n/i);
        }
    }
    sortArray(p, count);
    return p;
}

int* listPrimeFactors (int n)
{
    int count=countPrimeFactors(n);
    int index=0;
    int *p;
    do
    {
        p=(int*)malloc(n*sizeof(int));
    }while(p==NULL);
    for(int i=1; i<=n; i++)
    {
        if(n%i==0 && isPrime(i))
        {
            p[index]=i;
            index++;
        }
    }
    displayArray(p, count);
    return p;
}

int divTimes(int n, int a)
{
    int count=0;
    while(n%a==0)
    {
        n/=a;
        count++;
    }
    return count;
}

int* primeFactorize(int n)
{
    int count = countPrimeFactors(n);
    int* factors = listPrimeFactors(n);
    int* dtimes;
    do
    {
        dtimes=(int*)malloc(count*sizeof(int));
    }while (dtimes==NULL);
    int index=0;
    for(int i=0; i<count; i++)
    {
        dtimes[i]=divTimes(n, factors[i]);
    }
    int size=0;
    for(int i=0; i<count; i++)
    {
        for(int j=0; j<dtimes[i]; j++)
        {
            size++;
        }
    }
    int* factorization;
    do
    {
        factorization=(int*)malloc(size*sizeof(int));
    }while(factorization==NULL);
    for(int i=0; i<count; i++)
    {
        for(int j=0; j<dtimes[i]; j++)
        {
            factorization[index++]=factors[i];
        }
    }
    return factorization;
    
}
int main()
{
    int* a=primeFactorize(420);
    int count = countPrimeFactors(420);
    displayArray(a, 10);
}

int countPrimesTill (int n)
{
    int count=0;
    for (int i=1; i<abs(n); i++)
    {
        if(isPrime(i))
            count++;
    }
    return count;
}

int* listPrimesTill (int n)
{
    int index=0;
    int c=countPrimesTill(n);
    int *p;
    do
    {
        p=(int*)malloc(c*sizeof(int));
    }while(p==NULL);
    for(int i=2; i<n; i++)
    {
        if(isPrime(i))
        {
            p[index++]=i;
        }
    }
    sortArray(p, c);
    return p;
}

int* listPrimes (int n)
{
    int index=0;
    int *p;
    do
    {
        p=(int*)malloc(n*sizeof(int));
    }while(p==NULL);
    for(int i=2; index<n; i++)
    {
        if(isPrime(i))
        {
            p[index++]=i;
        }
    }
    sortArray(p, n);
    return p;
}


